// GENERATED CODE - DO NOT MODIFY BY HAND
// This code was generated by ObjectBox. To update it run the generator again:
// With a Flutter package, run `flutter pub run build_runner build`.
// With a Dart package, run `dart run build_runner build`.
// See also https://docs.objectbox.io/getting-started#generate-objectbox-code

// ignore_for_file: camel_case_types, depend_on_referenced_packages
// coverage:ignore-file

import 'dart:typed_data';

import 'package:flat_buffers/flat_buffers.dart' as fb;
import 'package:objectbox/internal.dart'; // generated code can access "internal" functionality
import 'package:objectbox/objectbox.dart';
import 'package:objectbox_flutter_libs/objectbox_flutter_libs.dart';

import '../models/author.dart';
import '../models/bible_verse.dart';
import '../models/custom_text.dart';
import '../models/external.dart';
import '../models/news_item.dart';
import '../models/playlist.dart';
import '../models/playlist_record.dart';
import '../models/settings.dart';
import '../models/song.dart';
import '../models/song_lyric.dart';
import '../models/songbook.dart';
import '../models/songbook_record.dart';
import '../models/tag.dart';

export 'package:objectbox/objectbox.dart'; // so that callers only have to import this file

final _entities = <ModelEntity>[
  ModelEntity(
      id: const IdUid(4, 6296825599350518621),
      name: 'Tag',
      lastPropertyId: const IdUid(4, 8038639158976530849),
      flags: 0,
      properties: <ModelProperty>[
        ModelProperty(
            id: const IdUid(1, 1202312863979149096),
            name: 'id',
            type: 6,
            flags: 129),
        ModelProperty(
            id: const IdUid(2, 5611127642092193137),
            name: 'name',
            type: 9,
            flags: 0),
        ModelProperty(
            id: const IdUid(3, 4931525366191811462),
            name: 'dbType',
            type: 6,
            flags: 0),
        ModelProperty(
            id: const IdUid(4, 8038639158976530849),
            name: 'songLyricsCount',
            type: 6,
            flags: 0)
      ],
      relations: <ModelRelation>[],
      backlinks: <ModelBacklink>[]),
  ModelEntity(
      id: const IdUid(6, 2374131111926575279),
      name: 'Song',
      lastPropertyId: const IdUid(2, 7814837987719399877),
      flags: 0,
      properties: <ModelProperty>[
        ModelProperty(
            id: const IdUid(1, 8353537239731189981),
            name: 'id',
            type: 6,
            flags: 129),
        ModelProperty(
            id: const IdUid(2, 7814837987719399877),
            name: 'name',
            type: 9,
            flags: 0)
      ],
      relations: <ModelRelation>[],
      backlinks: <ModelBacklink>[
        ModelBacklink(name: 'songLyrics', srcEntity: 'SongLyric', srcField: '')
      ]),
  ModelEntity(
      id: const IdUid(7, 8797415451663897865),
      name: 'Author',
      lastPropertyId: const IdUid(2, 4613344973069529154),
      flags: 0,
      properties: <ModelProperty>[
        ModelProperty(
            id: const IdUid(1, 3363642283487101516),
            name: 'id',
            type: 6,
            flags: 129),
        ModelProperty(
            id: const IdUid(2, 4613344973069529154),
            name: 'name',
            type: 9,
            flags: 0)
      ],
      relations: <ModelRelation>[],
      backlinks: <ModelBacklink>[]),
  ModelEntity(
      id: const IdUid(8, 2724259771969584896),
      name: 'Songbook',
      lastPropertyId: const IdUid(7, 6957339251542960973),
      flags: 0,
      properties: <ModelProperty>[
        ModelProperty(
            id: const IdUid(1, 4042315241527544300),
            name: 'id',
            type: 6,
            flags: 129),
        ModelProperty(
            id: const IdUid(2, 8660858498312652364),
            name: 'name',
            type: 9,
            flags: 0),
        ModelProperty(
            id: const IdUid(3, 3447729507208907805),
            name: 'shortcut',
            type: 9,
            flags: 0),
        ModelProperty(
            id: const IdUid(4, 4427598841893313809),
            name: 'color',
            type: 9,
            flags: 0),
        ModelProperty(
            id: const IdUid(5, 3006707744087714809),
            name: 'colorText',
            type: 9,
            flags: 0),
        ModelProperty(
            id: const IdUid(6, 7680416521438868557),
            name: 'isPrivate',
            type: 1,
            flags: 0),
        ModelProperty(
            id: const IdUid(7, 6957339251542960973),
            name: 'isPinned',
            type: 1,
            flags: 0)
      ],
      relations: <ModelRelation>[],
      backlinks: <ModelBacklink>[
        ModelBacklink(
            name: 'records', srcEntity: 'SongbookRecord', srcField: '')
      ]),
  ModelEntity(
      id: const IdUid(9, 7232145165103886962),
      name: 'SongbookRecord',
      lastPropertyId: const IdUid(9, 334605257073641595),
      flags: 0,
      properties: <ModelProperty>[
        ModelProperty(
            id: const IdUid(1, 6054907260033069130),
            name: 'id',
            type: 6,
            flags: 129),
        ModelProperty(
            id: const IdUid(7, 7196326332169539171),
            name: 'songLyricId',
            type: 11,
            flags: 520,
            indexId: const IdUid(3, 942306867161783693),
            relationTarget: 'SongLyric'),
        ModelProperty(
            id: const IdUid(8, 2070073359812025263),
            name: 'songbookId',
            type: 11,
            flags: 520,
            indexId: const IdUid(4, 8918108328092906748),
            relationTarget: 'Songbook'),
        ModelProperty(
            id: const IdUid(9, 334605257073641595),
            name: 'number',
            type: 9,
            flags: 0)
      ],
      relations: <ModelRelation>[],
      backlinks: <ModelBacklink>[]),
  ModelEntity(
      id: const IdUid(11, 6447883453535376640),
      name: 'SongLyric',
      lastPropertyId: const IdUid(31, 1452219602788211382),
      flags: 0,
      properties: <ModelProperty>[
        ModelProperty(
            id: const IdUid(1, 3863298287914509345),
            name: 'id',
            type: 6,
            flags: 129),
        ModelProperty(
            id: const IdUid(2, 441804169355063782),
            name: 'name',
            type: 9,
            flags: 0),
        ModelProperty(
            id: const IdUid(3, 172858861373732984),
            name: 'secondaryName1',
            type: 9,
            flags: 0),
        ModelProperty(
            id: const IdUid(4, 8016708352967187219),
            name: 'secondaryName2',
            type: 9,
            flags: 0),
        ModelProperty(
            id: const IdUid(5, 4090781135399724519),
            name: 'lyrics',
            type: 9,
            flags: 0),
        ModelProperty(
            id: const IdUid(6, 3380582964501408304),
            name: 'lilypond',
            type: 9,
            flags: 0),
        ModelProperty(
            id: const IdUid(7, 298128507441633315),
            name: 'lang',
            type: 9,
            flags: 0),
        ModelProperty(
            id: const IdUid(8, 4779117914827910420),
            name: 'langDescription',
            type: 9,
            flags: 0),
        ModelProperty(
            id: const IdUid(9, 6562831056286277746),
            name: 'songId',
            type: 11,
            flags: 520,
            indexId: const IdUid(6, 6968220845399115842),
            relationTarget: 'Song'),
        ModelProperty(
            id: const IdUid(11, 7728117412880047888),
            name: 'dbType',
            type: 6,
            flags: 0),
        ModelProperty(
            id: const IdUid(12, 4793601887131442231),
            name: 'hasChords',
            type: 1,
            flags: 0),
        ModelProperty(
            id: const IdUid(22, 4355414326890607438),
            name: 'accidentals',
            type: 6,
            flags: 0),
        ModelProperty(
            id: const IdUid(23, 7347294181262392126),
            name: 'showChords',
            type: 1,
            flags: 0),
        ModelProperty(
            id: const IdUid(24, 8592014509296857970),
            name: 'transposition',
            type: 6,
            flags: 0),
        ModelProperty(
            id: const IdUid(27, 6291458277285942163),
            name: 'settingsId',
            type: 11,
            flags: 520,
            indexId: const IdUid(22, 6689134858203517923),
            relationTarget: 'SongLyricSettingsModel'),
        ModelProperty(
            id: const IdUid(29, 1423809161795807367),
            name: 'internalId',
            type: 6,
            flags: 0),
        ModelProperty(
            id: const IdUid(30, 4119502192344556831),
            name: 'externalRenderedScores',
            type: 9,
            flags: 0),
        ModelProperty(
            id: const IdUid(31, 1452219602788211382),
            name: 'hymnology',
            type: 9,
            flags: 0)
      ],
      relations: <ModelRelation>[
        ModelRelation(
            id: const IdUid(6, 8595379047063016810),
            name: 'authors',
            targetId: const IdUid(7, 8797415451663897865)),
        ModelRelation(
            id: const IdUid(7, 8890618311243611972),
            name: 'tags',
            targetId: const IdUid(4, 6296825599350518621)),
        ModelRelation(
            id: const IdUid(9, 6609909260274628973),
            name: 'externals',
            targetId: const IdUid(13, 34413049226011067))
      ],
      backlinks: <ModelBacklink>[
        ModelBacklink(
            name: 'songbookRecords', srcEntity: 'SongbookRecord', srcField: ''),
        ModelBacklink(
            name: 'playlistRecords', srcEntity: 'PlaylistRecord', srcField: '')
      ]),
  ModelEntity(
      id: const IdUid(12, 4858060119845349265),
      name: 'NewsItem',
      lastPropertyId: const IdUid(4, 4137592721431574793),
      flags: 0,
      properties: <ModelProperty>[
        ModelProperty(
            id: const IdUid(1, 3981388212350529487),
            name: 'id',
            type: 6,
            flags: 129),
        ModelProperty(
            id: const IdUid(2, 7163479903263102026),
            name: 'text',
            type: 9,
            flags: 0),
        ModelProperty(
            id: const IdUid(3, 6038618770164161164),
            name: 'link',
            type: 9,
            flags: 0),
        ModelProperty(
            id: const IdUid(4, 4137592721431574793),
            name: 'expiresAt',
            type: 10,
            flags: 0)
      ],
      relations: <ModelRelation>[],
      backlinks: <ModelBacklink>[]),
  ModelEntity(
      id: const IdUid(13, 34413049226011067),
      name: 'External',
      lastPropertyId: const IdUid(7, 4552902403603048801),
      flags: 0,
      properties: <ModelProperty>[
        ModelProperty(
            id: const IdUid(1, 5237738498144927746),
            name: 'id',
            type: 6,
            flags: 129),
        ModelProperty(
            id: const IdUid(2, 6355284715787610869),
            name: 'publicName',
            type: 9,
            flags: 0),
        ModelProperty(
            id: const IdUid(3, 2268257428856178476),
            name: 'mediaId',
            type: 9,
            flags: 0),
        ModelProperty(
            id: const IdUid(4, 8053171722983356065),
            name: 'dbMediaType',
            type: 6,
            flags: 0),
        ModelProperty(
            id: const IdUid(6, 1240759115435120045),
            name: 'url',
            type: 9,
            flags: 0),
        ModelProperty(
            id: const IdUid(7, 4552902403603048801),
            name: 'songLyricId',
            type: 11,
            flags: 520,
            indexId: const IdUid(25, 6759144687015843733),
            relationTarget: 'SongLyric')
      ],
      relations: <ModelRelation>[],
      backlinks: <ModelBacklink>[]),
  ModelEntity(
      id: const IdUid(16, 2711299414835728808),
      name: 'Playlist',
      lastPropertyId: const IdUid(4, 344917746087617944),
      flags: 0,
      properties: <ModelProperty>[
        ModelProperty(
            id: const IdUid(1, 5853961398002098718),
            name: 'id',
            type: 6,
            flags: 129),
        ModelProperty(
            id: const IdUid(2, 4205856836876740672),
            name: 'name',
            type: 9,
            flags: 2080,
            indexId: const IdUid(14, 1347531346618730530)),
        ModelProperty(
            id: const IdUid(3, 8873413204595320183),
            name: 'rank',
            type: 6,
            flags: 0)
      ],
      relations: <ModelRelation>[],
      backlinks: <ModelBacklink>[
        ModelBacklink(
            name: 'records', srcEntity: 'PlaylistRecord', srcField: '')
      ]),
  ModelEntity(
      id: const IdUid(17, 7654860777539205773),
      name: 'PlaylistRecord',
      lastPropertyId: const IdUid(8, 3873057272621101277),
      flags: 0,
      properties: <ModelProperty>[
        ModelProperty(
            id: const IdUid(1, 2084793810234461107),
            name: 'id',
            type: 6,
            flags: 129),
        ModelProperty(
            id: const IdUid(3, 3680925814327867808),
            name: 'songLyricId',
            type: 11,
            flags: 520,
            indexId: const IdUid(12, 1014505544754464940),
            relationTarget: 'SongLyric'),
        ModelProperty(
            id: const IdUid(4, 2837928487534816535),
            name: 'playlistId',
            type: 11,
            flags: 520,
            indexId: const IdUid(13, 5091625997565988014),
            relationTarget: 'Playlist'),
        ModelProperty(
            id: const IdUid(5, 287030318006723005),
            name: 'rank',
            type: 6,
            flags: 0),
        ModelProperty(
            id: const IdUid(6, 3910634938425838689),
            name: 'customTextId',
            type: 11,
            flags: 520,
            indexId: const IdUid(20, 4666277981806120726),
            relationTarget: 'CustomText'),
        ModelProperty(
            id: const IdUid(7, 5967467250290572620),
            name: 'bibleVerseId',
            type: 11,
            flags: 520,
            indexId: const IdUid(21, 6699618113083989690),
            relationTarget: 'BibleVerse')
      ],
      relations: <ModelRelation>[],
      backlinks: <ModelBacklink>[]),
  ModelEntity(
      id: const IdUid(20, 8093518841538767418),
      name: 'BibleVerse',
      lastPropertyId: const IdUid(6, 3522228504437507385),
      flags: 0,
      properties: <ModelProperty>[
        ModelProperty(
            id: const IdUid(1, 6112900165100875406),
            name: 'id',
            type: 6,
            flags: 129),
        ModelProperty(
            id: const IdUid(2, 7350936359569733342),
            name: 'book',
            type: 6,
            flags: 0),
        ModelProperty(
            id: const IdUid(3, 657723057706050326),
            name: 'chapter',
            type: 6,
            flags: 0),
        ModelProperty(
            id: const IdUid(4, 9056646853926561691),
            name: 'startVerse',
            type: 6,
            flags: 0),
        ModelProperty(
            id: const IdUid(5, 2638018248609346393),
            name: 'endVerse',
            type: 6,
            flags: 0),
        ModelProperty(
            id: const IdUid(6, 3522228504437507385),
            name: 'text',
            type: 9,
            flags: 0)
      ],
      relations: <ModelRelation>[],
      backlinks: <ModelBacklink>[]),
  ModelEntity(
      id: const IdUid(21, 2063445298157793913),
      name: 'CustomText',
      lastPropertyId: const IdUid(3, 4470839687834790316),
      flags: 0,
      properties: <ModelProperty>[
        ModelProperty(
            id: const IdUid(1, 9044510006860898045),
            name: 'id',
            type: 6,
            flags: 129),
        ModelProperty(
            id: const IdUid(2, 2865456283844397183),
            name: 'name',
            type: 9,
            flags: 0),
        ModelProperty(
            id: const IdUid(3, 4470839687834790316),
            name: 'content',
            type: 9,
            flags: 0)
      ],
      relations: <ModelRelation>[],
      backlinks: <ModelBacklink>[]),
  ModelEntity(
      id: const IdUid(22, 3313311911381561450),
      name: 'SongLyricSettingsModel',
      lastPropertyId: const IdUid(6, 6538238091134320076),
      flags: 0,
      properties: <ModelProperty>[
        ModelProperty(
            id: const IdUid(1, 6941247299300405071),
            name: 'id',
            type: 6,
            flags: 129),
        ModelProperty(
            id: const IdUid(2, 2923647185517779947),
            name: 'showChords',
            type: 1,
            flags: 0),
        ModelProperty(
            id: const IdUid(3, 7697755545499354045),
            name: 'showMusicalNotes',
            type: 1,
            flags: 0),
        ModelProperty(
            id: const IdUid(4, 7957539658059684623),
            name: 'accidentals',
            type: 6,
            flags: 0),
        ModelProperty(
            id: const IdUid(5, 4772539694454545900),
            name: 'transposition',
            type: 6,
            flags: 0),
        ModelProperty(
            id: const IdUid(6, 6538238091134320076),
            name: 'songLyricId',
            type: 11,
            flags: 520,
            indexId: const IdUid(24, 2671655412393307456),
            relationTarget: 'SongLyric')
      ],
      relations: <ModelRelation>[],
      backlinks: <ModelBacklink>[])
];

/// Shortcut for [Store.new] that passes [getObjectBoxModel] and for Flutter
/// apps by default a [directory] using `defaultStoreDirectory()` from the
/// ObjectBox Flutter library.
///
/// Note: for desktop apps it is recommended to specify a unique [directory].
///
/// See [Store.new] for an explanation of all parameters.
Future<Store> openStore(
        {String? directory,
        int? maxDBSizeInKB,
        int? fileMode,
        int? maxReaders,
        bool queriesCaseSensitiveDefault = true,
        String? macosApplicationGroup}) async =>
    Store(getObjectBoxModel(),
        directory: directory ?? (await defaultStoreDirectory()).path,
        maxDBSizeInKB: maxDBSizeInKB,
        fileMode: fileMode,
        maxReaders: maxReaders,
        queriesCaseSensitiveDefault: queriesCaseSensitiveDefault,
        macosApplicationGroup: macosApplicationGroup);

/// Returns the ObjectBox model definition for this project for use with
/// [Store.new].
ModelDefinition getObjectBoxModel() {
  final model = ModelInfo(
      entities: _entities,
      lastEntityId: const IdUid(22, 3313311911381561450),
      lastIndexId: const IdUid(25, 6759144687015843733),
      lastRelationId: const IdUid(9, 6609909260274628973),
      lastSequenceId: const IdUid(0, 0),
      retiredEntityUids: const [
        6628950258912287707,
        3997966892313177785,
        4828503391288265608,
        5722656750256100534,
        3974850738104585390,
        7087359921340693986,
        3574257195436151857,
        4289723463740273072,
        308563676121461278
      ],
      retiredIndexUids: const [
        9023521533068155021,
        8226372830687146371,
        7685595388740378375,
        7916231218966853097,
        5349464891857123935,
        1850499091710419784,
        6416834576335019143,
        2335111573671041561,
        1526469212631298588
      ],
      retiredPropertyUids: const [
        1286404604582147955,
        2045942571545498429,
        4156807171975174171,
        2769258185308251592,
        2750485277817544042,
        57379581087889430,
        2303092288825628002,
        5181839766778648572,
        1535607057038781256,
        7214825174623022750,
        2487210589202474752,
        391283423985779645,
        6828233565720179886,
        2016746920009926401,
        1866660310130334498,
        8258290526986479967,
        9186643213110364361,
        2012362637196544559,
        4198504091761231768,
        2798094153154113871,
        809050937703252492,
        4774006349046573734,
        329289963093354246,
        1689786811235179787,
        6671414168712327567,
        638797381657980389,
        2411306619182484870,
        1231181773716438848,
        7671315634081304656,
        3009414053170717053,
        3242483719965434956,
        3010716229405627844,
        1606944041271966875,
        1676604361532699457,
        3755295400121515026,
        4796868076728380816,
        8676940974206202217,
        5223295552211929436,
        4602093041782453470,
        7304637183893981401,
        7146339985499275782,
        5949607464601688600,
        5480375422880047425,
        5734157863054487677,
        8389179145585346838,
        2057466685170398215,
        2245087066225826105,
        5458802551295315336,
        299538624348525419,
        7917435652412581048,
        344917746087617944,
        8296175755256605743,
        1715249534898951602,
        9195031951480790049,
        2394749474446949643,
        1060045570178656313,
        2261087093503428517,
        2772973546189811204,
        6246097383067926012,
        1429273622555481500,
        4919637654774237975,
        5849904806336203926,
        3530014358950602617,
        124942079172408792,
        8881930723356889494,
        8434279879851819318,
        4952449864415835601,
        2950767695190299953,
        6120913430319880953,
        5404942060880140897,
        7528607199616284548,
        3483625794157916143,
        3873057272621101277,
        8900800022749379441
      ],
      retiredRelationUids: const [
        7916874752771113838,
        8475939472281092043,
        908885689419134235,
        1345337331648128811
      ],
      modelVersion: 5,
      modelVersionParserMinimum: 5,
      version: 1);

  final bindings = <Type, EntityDefinition>{
    Tag: EntityDefinition<Tag>(
        model: _entities[0],
        toOneRelations: (Tag object) => [],
        toManyRelations: (Tag object) => {},
        getId: (Tag object) => object.id,
        setId: (Tag object, int id) {
          if (object.id != id) {
            throw ArgumentError('Field Tag.id is read-only '
                '(final or getter-only) and it was declared to be self-assigned. '
                'However, the currently inserted object (.id=${object.id}) '
                "doesn't match the inserted ID (ID $id). "
                'You must assign an ID before calling [box.put()].');
          }
        },
        objectToFB: (Tag object, fb.Builder fbb) {
          final nameOffset = fbb.writeString(object.name);
          fbb.startTable(5);
          fbb.addInt64(0, object.id);
          fbb.addOffset(1, nameOffset);
          fbb.addInt64(2, object.dbType);
          fbb.addInt64(3, object.songLyricsCount);
          fbb.finish(fbb.endTable());
          return object.id;
        },
        objectFromFB: (Store store, ByteData fbData) {
          final buffer = fb.BufferContext(fbData);
          final rootOffset = buffer.derefObject(0);
          final idParam =
              const fb.Int64Reader().vTableGet(buffer, rootOffset, 4, 0);
          final nameParam = const fb.StringReader(asciiOptimization: true)
              .vTableGet(buffer, rootOffset, 6, '');
          final dbTypeParam =
              const fb.Int64Reader().vTableGet(buffer, rootOffset, 8, 0);
          final songLyricsCountParam =
              const fb.Int64Reader().vTableGet(buffer, rootOffset, 10, 0);
          final object = Tag(
              id: idParam,
              name: nameParam,
              dbType: dbTypeParam,
              songLyricsCount: songLyricsCountParam);

          return object;
        }),
    Song: EntityDefinition<Song>(
        model: _entities[1],
        toOneRelations: (Song object) => [],
        toManyRelations: (Song object) => {
              RelInfo<SongLyric>.toOneBacklink(
                      9, object.id, (SongLyric srcObject) => srcObject.song):
                  object.songLyrics
            },
        getId: (Song object) => object.id,
        setId: (Song object, int id) {
          if (object.id != id) {
            throw ArgumentError('Field Song.id is read-only '
                '(final or getter-only) and it was declared to be self-assigned. '
                'However, the currently inserted object (.id=${object.id}) '
                "doesn't match the inserted ID (ID $id). "
                'You must assign an ID before calling [box.put()].');
          }
        },
        objectToFB: (Song object, fb.Builder fbb) {
          final nameOffset = fbb.writeString(object.name);
          fbb.startTable(3);
          fbb.addInt64(0, object.id);
          fbb.addOffset(1, nameOffset);
          fbb.finish(fbb.endTable());
          return object.id;
        },
        objectFromFB: (Store store, ByteData fbData) {
          final buffer = fb.BufferContext(fbData);
          final rootOffset = buffer.derefObject(0);
          final idParam =
              const fb.Int64Reader().vTableGet(buffer, rootOffset, 4, 0);
          final nameParam = const fb.StringReader(asciiOptimization: true)
              .vTableGet(buffer, rootOffset, 6, '');
          final songLyricsParam = ToMany<SongLyric>();
          final object =
              Song(id: idParam, name: nameParam, songLyrics: songLyricsParam);
          InternalToManyAccess.setRelInfo<Song>(
              object.songLyrics,
              store,
              RelInfo<SongLyric>.toOneBacklink(
                  9, object.id, (SongLyric srcObject) => srcObject.song));
          return object;
        }),
    Author: EntityDefinition<Author>(
        model: _entities[2],
        toOneRelations: (Author object) => [],
        toManyRelations: (Author object) => {},
        getId: (Author object) => object.id,
        setId: (Author object, int id) {
          if (object.id != id) {
            throw ArgumentError('Field Author.id is read-only '
                '(final or getter-only) and it was declared to be self-assigned. '
                'However, the currently inserted object (.id=${object.id}) '
                "doesn't match the inserted ID (ID $id). "
                'You must assign an ID before calling [box.put()].');
          }
        },
        objectToFB: (Author object, fb.Builder fbb) {
          final nameOffset = fbb.writeString(object.name);
          fbb.startTable(3);
          fbb.addInt64(0, object.id);
          fbb.addOffset(1, nameOffset);
          fbb.finish(fbb.endTable());
          return object.id;
        },
        objectFromFB: (Store store, ByteData fbData) {
          final buffer = fb.BufferContext(fbData);
          final rootOffset = buffer.derefObject(0);
          final idParam =
              const fb.Int64Reader().vTableGet(buffer, rootOffset, 4, 0);
          final nameParam = const fb.StringReader(asciiOptimization: true)
              .vTableGet(buffer, rootOffset, 6, '');
          final object = Author(id: idParam, name: nameParam);

          return object;
        }),
    Songbook: EntityDefinition<Songbook>(
        model: _entities[3],
        toOneRelations: (Songbook object) => [],
        toManyRelations: (Songbook object) => {
              RelInfo<SongbookRecord>.toOneBacklink(8, object.id,
                      (SongbookRecord srcObject) => srcObject.songbook):
                  object.records
            },
        getId: (Songbook object) => object.id,
        setId: (Songbook object, int id) {
          if (object.id != id) {
            throw ArgumentError('Field Songbook.id is read-only '
                '(final or getter-only) and it was declared to be self-assigned. '
                'However, the currently inserted object (.id=${object.id}) '
                "doesn't match the inserted ID (ID $id). "
                'You must assign an ID before calling [box.put()].');
          }
        },
        objectToFB: (Songbook object, fb.Builder fbb) {
          final nameOffset = fbb.writeString(object.name);
          final shortcutOffset = fbb.writeString(object.shortcut);
          final colorOffset =
              object.color == null ? null : fbb.writeString(object.color!);
          final colorTextOffset = object.colorText == null
              ? null
              : fbb.writeString(object.colorText!);
          fbb.startTable(8);
          fbb.addInt64(0, object.id);
          fbb.addOffset(1, nameOffset);
          fbb.addOffset(2, shortcutOffset);
          fbb.addOffset(3, colorOffset);
          fbb.addOffset(4, colorTextOffset);
          fbb.addBool(5, object.isPrivate);
          fbb.addBool(6, object.isPinned);
          fbb.finish(fbb.endTable());
          return object.id;
        },
        objectFromFB: (Store store, ByteData fbData) {
          final buffer = fb.BufferContext(fbData);
          final rootOffset = buffer.derefObject(0);
          final idParam =
              const fb.Int64Reader().vTableGet(buffer, rootOffset, 4, 0);
          final nameParam = const fb.StringReader(asciiOptimization: true)
              .vTableGet(buffer, rootOffset, 6, '');
          final shortcutParam = const fb.StringReader(asciiOptimization: true)
              .vTableGet(buffer, rootOffset, 8, '');
          final colorParam = const fb.StringReader(asciiOptimization: true)
              .vTableGetNullable(buffer, rootOffset, 10);
          final colorTextParam = const fb.StringReader(asciiOptimization: true)
              .vTableGetNullable(buffer, rootOffset, 12);
          final isPrivateParam =
              const fb.BoolReader().vTableGet(buffer, rootOffset, 14, false);
          final isPinnedParam =
              const fb.BoolReader().vTableGetNullable(buffer, rootOffset, 16);
          final recordsParam = ToMany<SongbookRecord>();
          final object = Songbook(
              id: idParam,
              name: nameParam,
              shortcut: shortcutParam,
              color: colorParam,
              colorText: colorTextParam,
              isPrivate: isPrivateParam,
              isPinned: isPinnedParam,
              records: recordsParam);
          InternalToManyAccess.setRelInfo<Songbook>(
              object.records,
              store,
              RelInfo<SongbookRecord>.toOneBacklink(8, object.id,
                  (SongbookRecord srcObject) => srcObject.songbook));
          return object;
        }),
    SongbookRecord: EntityDefinition<SongbookRecord>(
        model: _entities[4],
        toOneRelations: (SongbookRecord object) =>
            [object.songLyric, object.songbook],
        toManyRelations: (SongbookRecord object) => {},
        getId: (SongbookRecord object) => object.id,
        setId: (SongbookRecord object, int id) {
          if (object.id != id) {
            throw ArgumentError('Field SongbookRecord.id is read-only '
                '(final or getter-only) and it was declared to be self-assigned. '
                'However, the currently inserted object (.id=${object.id}) '
                "doesn't match the inserted ID (ID $id). "
                'You must assign an ID before calling [box.put()].');
          }
        },
        objectToFB: (SongbookRecord object, fb.Builder fbb) {
          final numberOffset = fbb.writeString(object.number);
          fbb.startTable(10);
          fbb.addInt64(0, object.id);
          fbb.addInt64(6, object.songLyric.targetId);
          fbb.addInt64(7, object.songbook.targetId);
          fbb.addOffset(8, numberOffset);
          fbb.finish(fbb.endTable());
          return object.id;
        },
        objectFromFB: (Store store, ByteData fbData) {
          final buffer = fb.BufferContext(fbData);
          final rootOffset = buffer.derefObject(0);
          final idParam =
              const fb.Int64Reader().vTableGet(buffer, rootOffset, 4, 0);
          final numberParam = const fb.StringReader(asciiOptimization: true)
              .vTableGet(buffer, rootOffset, 20, '');
          final songLyricParam = ToOne<SongLyric>(
              targetId:
                  const fb.Int64Reader().vTableGet(buffer, rootOffset, 16, 0));
          final songbookParam = ToOne<Songbook>(
              targetId:
                  const fb.Int64Reader().vTableGet(buffer, rootOffset, 18, 0));
          final object = SongbookRecord(
              id: idParam,
              number: numberParam,
              songLyric: songLyricParam,
              songbook: songbookParam);
          object.songLyric.attach(store);
          object.songbook.attach(store);
          return object;
        }),
    SongLyric: EntityDefinition<SongLyric>(
        model: _entities[5],
        toOneRelations: (SongLyric object) => [object.song, object.settings],
        toManyRelations: (SongLyric object) => {
              RelInfo<SongLyric>.toMany(6, object.id): object.authors,
              RelInfo<SongLyric>.toMany(7, object.id): object.tags,
              RelInfo<SongLyric>.toMany(9, object.id): object.externals,
              RelInfo<SongbookRecord>.toOneBacklink(7, object.id,
                      (SongbookRecord srcObject) => srcObject.songLyric):
                  object.songbookRecords,
              RelInfo<PlaylistRecord>.toOneBacklink(3, object.id,
                      (PlaylistRecord srcObject) => srcObject.songLyric):
                  object.playlistRecords
            },
        getId: (SongLyric object) => object.id,
        setId: (SongLyric object, int id) {
          if (object.id != id) {
            throw ArgumentError('Field SongLyric.id is read-only '
                '(final or getter-only) and it was declared to be self-assigned. '
                'However, the currently inserted object (.id=${object.id}) '
                "doesn't match the inserted ID (ID $id). "
                'You must assign an ID before calling [box.put()].');
          }
        },
        objectToFB: (SongLyric object, fb.Builder fbb) {
          final nameOffset = fbb.writeString(object.name);
          final secondaryName1Offset = object.secondaryName1 == null
              ? null
              : fbb.writeString(object.secondaryName1!);
          final secondaryName2Offset = object.secondaryName2 == null
              ? null
              : fbb.writeString(object.secondaryName2!);
          final lyricsOffset =
              object.lyrics == null ? null : fbb.writeString(object.lyrics!);
          final lilypondOffset = object.lilypond == null
              ? null
              : fbb.writeString(object.lilypond!);
          final langOffset = fbb.writeString(object.lang);
          final langDescriptionOffset = fbb.writeString(object.langDescription);
          final externalRenderedScoresOffset =
              object.externalRenderedScores == null
                  ? null
                  : fbb.writeString(object.externalRenderedScores!);
          final hymnologyOffset = fbb.writeString(object.hymnology);
          fbb.startTable(32);
          fbb.addInt64(0, object.id);
          fbb.addOffset(1, nameOffset);
          fbb.addOffset(2, secondaryName1Offset);
          fbb.addOffset(3, secondaryName2Offset);
          fbb.addOffset(4, lyricsOffset);
          fbb.addOffset(5, lilypondOffset);
          fbb.addOffset(6, langOffset);
          fbb.addOffset(7, langDescriptionOffset);
          fbb.addInt64(8, object.song.targetId);
          fbb.addInt64(10, object.dbType);
          fbb.addBool(11, object.hasChords);
          fbb.addInt64(21, object.accidentals);
          fbb.addBool(22, object.showChords);
          fbb.addInt64(23, object.transposition);
          fbb.addInt64(26, object.settings.targetId);
          fbb.addInt64(28, object.internalId);
          fbb.addOffset(29, externalRenderedScoresOffset);
          fbb.addOffset(30, hymnologyOffset);
          fbb.finish(fbb.endTable());
          return object.id;
        },
        objectFromFB: (Store store, ByteData fbData) {
          final buffer = fb.BufferContext(fbData);
          final rootOffset = buffer.derefObject(0);
          final idParam =
              const fb.Int64Reader().vTableGet(buffer, rootOffset, 4, 0);
          final internalIdParam =
              const fb.Int64Reader().vTableGet(buffer, rootOffset, 60, 0);
          final nameParam = const fb.StringReader(asciiOptimization: true)
              .vTableGet(buffer, rootOffset, 6, '');
          final secondaryName1Param =
              const fb.StringReader(asciiOptimization: true)
                  .vTableGetNullable(buffer, rootOffset, 8);
          final secondaryName2Param =
              const fb.StringReader(asciiOptimization: true)
                  .vTableGetNullable(buffer, rootOffset, 10);
          final lyricsParam = const fb.StringReader(asciiOptimization: true)
              .vTableGetNullable(buffer, rootOffset, 12);
          final lilypondParam = const fb.StringReader(asciiOptimization: true)
              .vTableGetNullable(buffer, rootOffset, 14);
          final externalRenderedScoresParam =
              const fb.StringReader(asciiOptimization: true)
                  .vTableGetNullable(buffer, rootOffset, 62);
          final hymnologyParam = const fb.StringReader(asciiOptimization: true)
              .vTableGet(buffer, rootOffset, 64, '');
          final langParam = const fb.StringReader(asciiOptimization: true)
              .vTableGet(buffer, rootOffset, 16, '');
          final langDescriptionParam =
              const fb.StringReader(asciiOptimization: true)
                  .vTableGet(buffer, rootOffset, 18, '');
          final dbTypeParam =
              const fb.Int64Reader().vTableGet(buffer, rootOffset, 24, 0);
          final hasChordsParam =
              const fb.BoolReader().vTableGet(buffer, rootOffset, 26, false);
          final accidentalsParam =
              const fb.Int64Reader().vTableGetNullable(buffer, rootOffset, 46);
          final showChordsParam =
              const fb.BoolReader().vTableGetNullable(buffer, rootOffset, 48);
          final transpositionParam =
              const fb.Int64Reader().vTableGetNullable(buffer, rootOffset, 50);
          final songParam = ToOne<Song>(
              targetId:
                  const fb.Int64Reader().vTableGet(buffer, rootOffset, 20, 0));
          final settingsParam = ToOne<SongLyricSettingsModel>(
              targetId:
                  const fb.Int64Reader().vTableGet(buffer, rootOffset, 56, 0));
          final authorsParam = ToMany<Author>();
          final tagsParam = ToMany<Tag>();
          final externalsParam = ToMany<External>();
          final songbookRecordsParam = ToMany<SongbookRecord>();
          final playlistRecordsParam = ToMany<PlaylistRecord>();
          final object = SongLyric(
              id: idParam,
              internalId: internalIdParam,
              name: nameParam,
              secondaryName1: secondaryName1Param,
              secondaryName2: secondaryName2Param,
              lyrics: lyricsParam,
              lilypond: lilypondParam,
              externalRenderedScores: externalRenderedScoresParam,
              hymnology: hymnologyParam,
              lang: langParam,
              langDescription: langDescriptionParam,
              dbType: dbTypeParam,
              hasChords: hasChordsParam,
              accidentals: accidentalsParam,
              showChords: showChordsParam,
              transposition: transpositionParam,
              song: songParam,
              settings: settingsParam,
              authors: authorsParam,
              tags: tagsParam,
              externals: externalsParam,
              songbookRecords: songbookRecordsParam,
              playlistRecords: playlistRecordsParam);
          object.song.attach(store);
          object.settings.attach(store);
          InternalToManyAccess.setRelInfo<SongLyric>(
              object.authors, store, RelInfo<SongLyric>.toMany(6, object.id));
          InternalToManyAccess.setRelInfo<SongLyric>(
              object.tags, store, RelInfo<SongLyric>.toMany(7, object.id));
          InternalToManyAccess.setRelInfo<SongLyric>(
              object.externals, store, RelInfo<SongLyric>.toMany(9, object.id));
          InternalToManyAccess.setRelInfo<SongLyric>(
              object.songbookRecords,
              store,
              RelInfo<SongbookRecord>.toOneBacklink(7, object.id,
                  (SongbookRecord srcObject) => srcObject.songLyric));
          InternalToManyAccess.setRelInfo<SongLyric>(
              object.playlistRecords,
              store,
              RelInfo<PlaylistRecord>.toOneBacklink(3, object.id,
                  (PlaylistRecord srcObject) => srcObject.songLyric));
          return object;
        }),
    NewsItem: EntityDefinition<NewsItem>(
        model: _entities[6],
        toOneRelations: (NewsItem object) => [],
        toManyRelations: (NewsItem object) => {},
        getId: (NewsItem object) => object.id,
        setId: (NewsItem object, int id) {
          if (object.id != id) {
            throw ArgumentError('Field NewsItem.id is read-only '
                '(final or getter-only) and it was declared to be self-assigned. '
                'However, the currently inserted object (.id=${object.id}) '
                "doesn't match the inserted ID (ID $id). "
                'You must assign an ID before calling [box.put()].');
          }
        },
        objectToFB: (NewsItem object, fb.Builder fbb) {
          final textOffset = fbb.writeString(object.text);
          final linkOffset = fbb.writeString(object.link);
          fbb.startTable(5);
          fbb.addInt64(0, object.id);
          fbb.addOffset(1, textOffset);
          fbb.addOffset(2, linkOffset);
          fbb.addInt64(3, object.expiresAt?.millisecondsSinceEpoch);
          fbb.finish(fbb.endTable());
          return object.id;
        },
        objectFromFB: (Store store, ByteData fbData) {
          final buffer = fb.BufferContext(fbData);
          final rootOffset = buffer.derefObject(0);
          final expiresAtValue =
              const fb.Int64Reader().vTableGetNullable(buffer, rootOffset, 10);
          final idParam =
              const fb.Int64Reader().vTableGet(buffer, rootOffset, 4, 0);
          final textParam = const fb.StringReader(asciiOptimization: true)
              .vTableGet(buffer, rootOffset, 6, '');
          final linkParam = const fb.StringReader(asciiOptimization: true)
              .vTableGet(buffer, rootOffset, 8, '');
          final expiresAtParam = expiresAtValue == null
              ? null
              : DateTime.fromMillisecondsSinceEpoch(expiresAtValue);
          final object = NewsItem(
              id: idParam,
              text: textParam,
              link: linkParam,
              expiresAt: expiresAtParam);

          return object;
        }),
    External: EntityDefinition<External>(
        model: _entities[7],
        toOneRelations: (External object) => [object.songLyric],
        toManyRelations: (External object) => {},
        getId: (External object) => object.id,
        setId: (External object, int id) {
          if (object.id != id) {
            throw ArgumentError('Field External.id is read-only '
                '(final or getter-only) and it was declared to be self-assigned. '
                'However, the currently inserted object (.id=${object.id}) '
                "doesn't match the inserted ID (ID $id). "
                'You must assign an ID before calling [box.put()].');
          }
        },
        objectToFB: (External object, fb.Builder fbb) {
          final publicNameOffset = fbb.writeString(object.publicName);
          final mediaIdOffset =
              object.mediaId == null ? null : fbb.writeString(object.mediaId!);
          final urlOffset =
              object.url == null ? null : fbb.writeString(object.url!);
          fbb.startTable(8);
          fbb.addInt64(0, object.id);
          fbb.addOffset(1, publicNameOffset);
          fbb.addOffset(2, mediaIdOffset);
          fbb.addInt64(3, object.dbMediaType);
          fbb.addOffset(5, urlOffset);
          fbb.addInt64(6, object.songLyric.targetId);
          fbb.finish(fbb.endTable());
          return object.id;
        },
        objectFromFB: (Store store, ByteData fbData) {
          final buffer = fb.BufferContext(fbData);
          final rootOffset = buffer.derefObject(0);
          final idParam =
              const fb.Int64Reader().vTableGet(buffer, rootOffset, 4, 0);
          final publicNameParam = const fb.StringReader(asciiOptimization: true)
              .vTableGet(buffer, rootOffset, 6, '');
          final mediaIdParam = const fb.StringReader(asciiOptimization: true)
              .vTableGetNullable(buffer, rootOffset, 8);
          final urlParam = const fb.StringReader(asciiOptimization: true)
              .vTableGetNullable(buffer, rootOffset, 14);
          final dbMediaTypeParam =
              const fb.Int64Reader().vTableGet(buffer, rootOffset, 10, 0);
          final songLyricParam = ToOne<SongLyric>(
              targetId:
                  const fb.Int64Reader().vTableGet(buffer, rootOffset, 16, 0));
          final object = External(
              id: idParam,
              publicName: publicNameParam,
              mediaId: mediaIdParam,
              url: urlParam,
              dbMediaType: dbMediaTypeParam,
              songLyric: songLyricParam);
          object.songLyric.attach(store);
          return object;
        }),
    Playlist: EntityDefinition<Playlist>(
        model: _entities[8],
        toOneRelations: (Playlist object) => [],
        toManyRelations: (Playlist object) => {
              RelInfo<PlaylistRecord>.toOneBacklink(4, object.id,
                      (PlaylistRecord srcObject) => srcObject.playlist):
                  object.records
            },
        getId: (Playlist object) => object.id,
        setId: (Playlist object, int id) {
          if (object.id != id) {
            throw ArgumentError('Field Playlist.id is read-only '
                '(final or getter-only) and it was declared to be self-assigned. '
                'However, the currently inserted object (.id=${object.id}) '
                "doesn't match the inserted ID (ID $id). "
                'You must assign an ID before calling [box.put()].');
          }
        },
        objectToFB: (Playlist object, fb.Builder fbb) {
          final nameOffset = fbb.writeString(object.name);
          fbb.startTable(5);
          fbb.addInt64(0, object.id);
          fbb.addOffset(1, nameOffset);
          fbb.addInt64(2, object.rank);
          fbb.finish(fbb.endTable());
          return object.id;
        },
        objectFromFB: (Store store, ByteData fbData) {
          final buffer = fb.BufferContext(fbData);
          final rootOffset = buffer.derefObject(0);
          final idParam =
              const fb.Int64Reader().vTableGet(buffer, rootOffset, 4, 0);
          final nameParam = const fb.StringReader(asciiOptimization: true)
              .vTableGet(buffer, rootOffset, 6, '');
          final rankParam =
              const fb.Int64Reader().vTableGet(buffer, rootOffset, 8, 0);
          final recordsParam = ToMany<PlaylistRecord>();
          final object = Playlist(
              id: idParam,
              name: nameParam,
              rank: rankParam,
              records: recordsParam);
          InternalToManyAccess.setRelInfo<Playlist>(
              object.records,
              store,
              RelInfo<PlaylistRecord>.toOneBacklink(4, object.id,
                  (PlaylistRecord srcObject) => srcObject.playlist));
          return object;
        }),
    PlaylistRecord: EntityDefinition<PlaylistRecord>(
        model: _entities[9],
        toOneRelations: (PlaylistRecord object) => [
              object.songLyric,
              object.playlist,
              object.customText,
              object.bibleVerse
            ],
        toManyRelations: (PlaylistRecord object) => {},
        getId: (PlaylistRecord object) => object.id,
        setId: (PlaylistRecord object, int id) {
          if (object.id != id) {
            throw ArgumentError('Field PlaylistRecord.id is read-only '
                '(final or getter-only) and it was declared to be self-assigned. '
                'However, the currently inserted object (.id=${object.id}) '
                "doesn't match the inserted ID (ID $id). "
                'You must assign an ID before calling [box.put()].');
          }
        },
        objectToFB: (PlaylistRecord object, fb.Builder fbb) {
          fbb.startTable(9);
          fbb.addInt64(0, object.id);
          fbb.addInt64(2, object.songLyric.targetId);
          fbb.addInt64(3, object.playlist.targetId);
          fbb.addInt64(4, object.rank);
          fbb.addInt64(5, object.customText.targetId);
          fbb.addInt64(6, object.bibleVerse.targetId);
          fbb.finish(fbb.endTable());
          return object.id;
        },
        objectFromFB: (Store store, ByteData fbData) {
          final buffer = fb.BufferContext(fbData);
          final rootOffset = buffer.derefObject(0);
          final idParam =
              const fb.Int64Reader().vTableGet(buffer, rootOffset, 4, 0);
          final rankParam =
              const fb.Int64Reader().vTableGet(buffer, rootOffset, 12, 0);
          final songLyricParam = ToOne<SongLyric>(
              targetId:
                  const fb.Int64Reader().vTableGet(buffer, rootOffset, 8, 0));
          final customTextParam = ToOne<CustomText>(
              targetId:
                  const fb.Int64Reader().vTableGet(buffer, rootOffset, 14, 0));
          final bibleVerseParam = ToOne<BibleVerse>(
              targetId:
                  const fb.Int64Reader().vTableGet(buffer, rootOffset, 16, 0));
          final playlistParam = ToOne<Playlist>(
              targetId:
                  const fb.Int64Reader().vTableGet(buffer, rootOffset, 10, 0));
          final object = PlaylistRecord(
              id: idParam,
              rank: rankParam,
              songLyric: songLyricParam,
              customText: customTextParam,
              bibleVerse: bibleVerseParam,
              playlist: playlistParam);
          object.songLyric.attach(store);
          object.playlist.attach(store);
          object.customText.attach(store);
          object.bibleVerse.attach(store);
          return object;
        }),
    BibleVerse: EntityDefinition<BibleVerse>(
        model: _entities[10],
        toOneRelations: (BibleVerse object) => [],
        toManyRelations: (BibleVerse object) => {},
        getId: (BibleVerse object) => object.id,
        setId: (BibleVerse object, int id) {
          if (object.id != id) {
            throw ArgumentError('Field BibleVerse.id is read-only '
                '(final or getter-only) and it was declared to be self-assigned. '
                'However, the currently inserted object (.id=${object.id}) '
                "doesn't match the inserted ID (ID $id). "
                'You must assign an ID before calling [box.put()].');
          }
        },
        objectToFB: (BibleVerse object, fb.Builder fbb) {
          final textOffset = fbb.writeString(object.text);
          fbb.startTable(7);
          fbb.addInt64(0, object.id);
          fbb.addInt64(1, object.book);
          fbb.addInt64(2, object.chapter);
          fbb.addInt64(3, object.startVerse);
          fbb.addInt64(4, object.endVerse);
          fbb.addOffset(5, textOffset);
          fbb.finish(fbb.endTable());
          return object.id;
        },
        objectFromFB: (Store store, ByteData fbData) {
          final buffer = fb.BufferContext(fbData);
          final rootOffset = buffer.derefObject(0);
          final idParam =
              const fb.Int64Reader().vTableGet(buffer, rootOffset, 4, 0);
          final bookParam =
              const fb.Int64Reader().vTableGet(buffer, rootOffset, 6, 0);
          final chapterParam =
              const fb.Int64Reader().vTableGet(buffer, rootOffset, 8, 0);
          final startVerseParam =
              const fb.Int64Reader().vTableGet(buffer, rootOffset, 10, 0);
          final endVerseParam =
              const fb.Int64Reader().vTableGetNullable(buffer, rootOffset, 12);
          final textParam = const fb.StringReader(asciiOptimization: true)
              .vTableGet(buffer, rootOffset, 14, '');
          final object = BibleVerse(
              id: idParam,
              book: bookParam,
              chapter: chapterParam,
              startVerse: startVerseParam,
              endVerse: endVerseParam,
              text: textParam);

          return object;
        }),
    CustomText: EntityDefinition<CustomText>(
        model: _entities[11],
        toOneRelations: (CustomText object) => [],
        toManyRelations: (CustomText object) => {},
        getId: (CustomText object) => object.id,
        setId: (CustomText object, int id) {
          if (object.id != id) {
            throw ArgumentError('Field CustomText.id is read-only '
                '(final or getter-only) and it was declared to be self-assigned. '
                'However, the currently inserted object (.id=${object.id}) '
                "doesn't match the inserted ID (ID $id). "
                'You must assign an ID before calling [box.put()].');
          }
        },
        objectToFB: (CustomText object, fb.Builder fbb) {
          final nameOffset = fbb.writeString(object.name);
          final contentOffset = fbb.writeString(object.content);
          fbb.startTable(4);
          fbb.addInt64(0, object.id);
          fbb.addOffset(1, nameOffset);
          fbb.addOffset(2, contentOffset);
          fbb.finish(fbb.endTable());
          return object.id;
        },
        objectFromFB: (Store store, ByteData fbData) {
          final buffer = fb.BufferContext(fbData);
          final rootOffset = buffer.derefObject(0);
          final idParam =
              const fb.Int64Reader().vTableGet(buffer, rootOffset, 4, 0);
          final nameParam = const fb.StringReader(asciiOptimization: true)
              .vTableGet(buffer, rootOffset, 6, '');
          final contentParam = const fb.StringReader(asciiOptimization: true)
              .vTableGet(buffer, rootOffset, 8, '');
          final object =
              CustomText(id: idParam, name: nameParam, content: contentParam);

          return object;
        }),
    SongLyricSettingsModel: EntityDefinition<SongLyricSettingsModel>(
        model: _entities[12],
        toOneRelations: (SongLyricSettingsModel object) => [object.songLyric],
        toManyRelations: (SongLyricSettingsModel object) => {},
        getId: (SongLyricSettingsModel object) => object.id,
        setId: (SongLyricSettingsModel object, int id) {
          if (object.id != id) {
            throw ArgumentError('Field SongLyricSettingsModel.id is read-only '
                '(final or getter-only) and it was declared to be self-assigned. '
                'However, the currently inserted object (.id=${object.id}) '
                "doesn't match the inserted ID (ID $id). "
                'You must assign an ID before calling [box.put()].');
          }
        },
        objectToFB: (SongLyricSettingsModel object, fb.Builder fbb) {
          fbb.startTable(7);
          fbb.addInt64(0, object.id);
          fbb.addBool(1, object.showChords);
          fbb.addBool(2, object.showMusicalNotes);
          fbb.addInt64(3, object.accidentals);
          fbb.addInt64(4, object.transposition);
          fbb.addInt64(5, object.songLyric.targetId);
          fbb.finish(fbb.endTable());
          return object.id;
        },
        objectFromFB: (Store store, ByteData fbData) {
          final buffer = fb.BufferContext(fbData);
          final rootOffset = buffer.derefObject(0);
          final idParam =
              const fb.Int64Reader().vTableGet(buffer, rootOffset, 4, 0);
          final showChordsParam =
              const fb.BoolReader().vTableGet(buffer, rootOffset, 6, false);
          final showMusicalNotesParam =
              const fb.BoolReader().vTableGet(buffer, rootOffset, 8, false);
          final accidentalsParam =
              const fb.Int64Reader().vTableGetNullable(buffer, rootOffset, 10);
          final transpositionParam =
              const fb.Int64Reader().vTableGet(buffer, rootOffset, 12, 0);
          final songLyricParam = ToOne<SongLyric>(
              targetId:
                  const fb.Int64Reader().vTableGet(buffer, rootOffset, 14, 0));
          final object = SongLyricSettingsModel(
              id: idParam,
              showChords: showChordsParam,
              showMusicalNotes: showMusicalNotesParam,
              accidentals: accidentalsParam,
              transposition: transpositionParam,
              songLyric: songLyricParam);
          object.songLyric.attach(store);
          return object;
        })
  };

  return ModelDefinition(model, bindings);
}

/// [Tag] entity fields to define ObjectBox queries.
class Tag_ {
  /// see [Tag.id]
  static final id = QueryIntegerProperty<Tag>(_entities[0].properties[0]);

  /// see [Tag.name]
  static final name = QueryStringProperty<Tag>(_entities[0].properties[1]);

  /// see [Tag.dbType]
  static final dbType = QueryIntegerProperty<Tag>(_entities[0].properties[2]);

  /// see [Tag.songLyricsCount]
  static final songLyricsCount =
      QueryIntegerProperty<Tag>(_entities[0].properties[3]);
}

/// [Song] entity fields to define ObjectBox queries.
class Song_ {
  /// see [Song.id]
  static final id = QueryIntegerProperty<Song>(_entities[1].properties[0]);

  /// see [Song.name]
  static final name = QueryStringProperty<Song>(_entities[1].properties[1]);
}

/// [Author] entity fields to define ObjectBox queries.
class Author_ {
  /// see [Author.id]
  static final id = QueryIntegerProperty<Author>(_entities[2].properties[0]);

  /// see [Author.name]
  static final name = QueryStringProperty<Author>(_entities[2].properties[1]);
}

/// [Songbook] entity fields to define ObjectBox queries.
class Songbook_ {
  /// see [Songbook.id]
  static final id = QueryIntegerProperty<Songbook>(_entities[3].properties[0]);

  /// see [Songbook.name]
  static final name = QueryStringProperty<Songbook>(_entities[3].properties[1]);

  /// see [Songbook.shortcut]
  static final shortcut =
      QueryStringProperty<Songbook>(_entities[3].properties[2]);

  /// see [Songbook.color]
  static final color =
      QueryStringProperty<Songbook>(_entities[3].properties[3]);

  /// see [Songbook.colorText]
  static final colorText =
      QueryStringProperty<Songbook>(_entities[3].properties[4]);

  /// see [Songbook.isPrivate]
  static final isPrivate =
      QueryBooleanProperty<Songbook>(_entities[3].properties[5]);

  /// see [Songbook.isPinned]
  static final isPinned =
      QueryBooleanProperty<Songbook>(_entities[3].properties[6]);
}

/// [SongbookRecord] entity fields to define ObjectBox queries.
class SongbookRecord_ {
  /// see [SongbookRecord.id]
  static final id =
      QueryIntegerProperty<SongbookRecord>(_entities[4].properties[0]);

  /// see [SongbookRecord.songLyric]
  static final songLyric =
      QueryRelationToOne<SongbookRecord, SongLyric>(_entities[4].properties[1]);

  /// see [SongbookRecord.songbook]
  static final songbook =
      QueryRelationToOne<SongbookRecord, Songbook>(_entities[4].properties[2]);

  /// see [SongbookRecord.number]
  static final number =
      QueryStringProperty<SongbookRecord>(_entities[4].properties[3]);
}

/// [SongLyric] entity fields to define ObjectBox queries.
class SongLyric_ {
  /// see [SongLyric.id]
  static final id = QueryIntegerProperty<SongLyric>(_entities[5].properties[0]);

  /// see [SongLyric.name]
  static final name =
      QueryStringProperty<SongLyric>(_entities[5].properties[1]);

  /// see [SongLyric.secondaryName1]
  static final secondaryName1 =
      QueryStringProperty<SongLyric>(_entities[5].properties[2]);

  /// see [SongLyric.secondaryName2]
  static final secondaryName2 =
      QueryStringProperty<SongLyric>(_entities[5].properties[3]);

  /// see [SongLyric.lyrics]
  static final lyrics =
      QueryStringProperty<SongLyric>(_entities[5].properties[4]);

  /// see [SongLyric.lilypond]
  static final lilypond =
      QueryStringProperty<SongLyric>(_entities[5].properties[5]);

  /// see [SongLyric.lang]
  static final lang =
      QueryStringProperty<SongLyric>(_entities[5].properties[6]);

  /// see [SongLyric.langDescription]
  static final langDescription =
      QueryStringProperty<SongLyric>(_entities[5].properties[7]);

  /// see [SongLyric.song]
  static final song =
      QueryRelationToOne<SongLyric, Song>(_entities[5].properties[8]);

  /// see [SongLyric.dbType]
  static final dbType =
      QueryIntegerProperty<SongLyric>(_entities[5].properties[9]);

  /// see [SongLyric.hasChords]
  static final hasChords =
      QueryBooleanProperty<SongLyric>(_entities[5].properties[10]);

  /// see [SongLyric.accidentals]
  static final accidentals =
      QueryIntegerProperty<SongLyric>(_entities[5].properties[11]);

  /// see [SongLyric.showChords]
  static final showChords =
      QueryBooleanProperty<SongLyric>(_entities[5].properties[12]);

  /// see [SongLyric.transposition]
  static final transposition =
      QueryIntegerProperty<SongLyric>(_entities[5].properties[13]);

  /// see [SongLyric.settings]
  static final settings = QueryRelationToOne<SongLyric, SongLyricSettingsModel>(
      _entities[5].properties[14]);

  /// see [SongLyric.internalId]
  static final internalId =
      QueryIntegerProperty<SongLyric>(_entities[5].properties[15]);

  /// see [SongLyric.externalRenderedScores]
  static final externalRenderedScores =
      QueryStringProperty<SongLyric>(_entities[5].properties[16]);

  /// see [SongLyric.hymnology]
  static final hymnology =
      QueryStringProperty<SongLyric>(_entities[5].properties[17]);

  /// see [SongLyric.authors]
  static final authors =
      QueryRelationToMany<SongLyric, Author>(_entities[5].relations[0]);

  /// see [SongLyric.tags]
  static final tags =
      QueryRelationToMany<SongLyric, Tag>(_entities[5].relations[1]);

  /// see [SongLyric.externals]
  static final externals =
      QueryRelationToMany<SongLyric, External>(_entities[5].relations[2]);
}

/// [NewsItem] entity fields to define ObjectBox queries.
class NewsItem_ {
  /// see [NewsItem.id]
  static final id = QueryIntegerProperty<NewsItem>(_entities[6].properties[0]);

  /// see [NewsItem.text]
  static final text = QueryStringProperty<NewsItem>(_entities[6].properties[1]);

  /// see [NewsItem.link]
  static final link = QueryStringProperty<NewsItem>(_entities[6].properties[2]);

  /// see [NewsItem.expiresAt]
  static final expiresAt =
      QueryIntegerProperty<NewsItem>(_entities[6].properties[3]);
}

/// [External] entity fields to define ObjectBox queries.
class External_ {
  /// see [External.id]
  static final id = QueryIntegerProperty<External>(_entities[7].properties[0]);

  /// see [External.publicName]
  static final publicName =
      QueryStringProperty<External>(_entities[7].properties[1]);

  /// see [External.mediaId]
  static final mediaId =
      QueryStringProperty<External>(_entities[7].properties[2]);

  /// see [External.dbMediaType]
  static final dbMediaType =
      QueryIntegerProperty<External>(_entities[7].properties[3]);

  /// see [External.url]
  static final url = QueryStringProperty<External>(_entities[7].properties[4]);

  /// see [External.songLyric]
  static final songLyric =
      QueryRelationToOne<External, SongLyric>(_entities[7].properties[5]);
}

/// [Playlist] entity fields to define ObjectBox queries.
class Playlist_ {
  /// see [Playlist.id]
  static final id = QueryIntegerProperty<Playlist>(_entities[8].properties[0]);

  /// see [Playlist.name]
  static final name = QueryStringProperty<Playlist>(_entities[8].properties[1]);

  /// see [Playlist.rank]
  static final rank =
      QueryIntegerProperty<Playlist>(_entities[8].properties[2]);
}

/// [PlaylistRecord] entity fields to define ObjectBox queries.
class PlaylistRecord_ {
  /// see [PlaylistRecord.id]
  static final id =
      QueryIntegerProperty<PlaylistRecord>(_entities[9].properties[0]);

  /// see [PlaylistRecord.songLyric]
  static final songLyric =
      QueryRelationToOne<PlaylistRecord, SongLyric>(_entities[9].properties[1]);

  /// see [PlaylistRecord.playlist]
  static final playlist =
      QueryRelationToOne<PlaylistRecord, Playlist>(_entities[9].properties[2]);

  /// see [PlaylistRecord.rank]
  static final rank =
      QueryIntegerProperty<PlaylistRecord>(_entities[9].properties[3]);

  /// see [PlaylistRecord.customText]
  static final customText = QueryRelationToOne<PlaylistRecord, CustomText>(
      _entities[9].properties[4]);

  /// see [PlaylistRecord.bibleVerse]
  static final bibleVerse = QueryRelationToOne<PlaylistRecord, BibleVerse>(
      _entities[9].properties[5]);
}

/// [BibleVerse] entity fields to define ObjectBox queries.
class BibleVerse_ {
  /// see [BibleVerse.id]
  static final id =
      QueryIntegerProperty<BibleVerse>(_entities[10].properties[0]);

  /// see [BibleVerse.book]
  static final book =
      QueryIntegerProperty<BibleVerse>(_entities[10].properties[1]);

  /// see [BibleVerse.chapter]
  static final chapter =
      QueryIntegerProperty<BibleVerse>(_entities[10].properties[2]);

  /// see [BibleVerse.startVerse]
  static final startVerse =
      QueryIntegerProperty<BibleVerse>(_entities[10].properties[3]);

  /// see [BibleVerse.endVerse]
  static final endVerse =
      QueryIntegerProperty<BibleVerse>(_entities[10].properties[4]);

  /// see [BibleVerse.text]
  static final text =
      QueryStringProperty<BibleVerse>(_entities[10].properties[5]);
}

/// [CustomText] entity fields to define ObjectBox queries.
class CustomText_ {
  /// see [CustomText.id]
  static final id =
      QueryIntegerProperty<CustomText>(_entities[11].properties[0]);

  /// see [CustomText.name]
  static final name =
      QueryStringProperty<CustomText>(_entities[11].properties[1]);

  /// see [CustomText.content]
  static final content =
      QueryStringProperty<CustomText>(_entities[11].properties[2]);
}

/// [SongLyricSettingsModel] entity fields to define ObjectBox queries.
class SongLyricSettingsModel_ {
  /// see [SongLyricSettingsModel.id]
  static final id =
      QueryIntegerProperty<SongLyricSettingsModel>(_entities[12].properties[0]);

  /// see [SongLyricSettingsModel.showChords]
  static final showChords =
      QueryBooleanProperty<SongLyricSettingsModel>(_entities[12].properties[1]);

  /// see [SongLyricSettingsModel.showMusicalNotes]
  static final showMusicalNotes =
      QueryBooleanProperty<SongLyricSettingsModel>(_entities[12].properties[2]);

  /// see [SongLyricSettingsModel.accidentals]
  static final accidentals =
      QueryIntegerProperty<SongLyricSettingsModel>(_entities[12].properties[3]);

  /// see [SongLyricSettingsModel.transposition]
  static final transposition =
      QueryIntegerProperty<SongLyricSettingsModel>(_entities[12].properties[4]);

  /// see [SongLyricSettingsModel.songLyric]
  static final songLyric =
      QueryRelationToOne<SongLyricSettingsModel, SongLyric>(
          _entities[12].properties[5]);
}
